

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/head.png">
  <link rel="icon" href="/img/head.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Myywee">
  <meta name="keywords" content="">
  
    <meta name="description" content="Something of JavaJava的构造器基本语法  [修饰符] 方法名（形参列表） {方法体} 构造器没有返回值 方法名和类名字必须一样 参数列表和成员方法一样的规则 构造器的调用由系统完成  基本介绍 构造器（constructor）又叫构造方法，是类的一种特殊方法，它的主要作用是完成对新对象的初始化。 注意事项和使用细节  一个类可以定义多个不同的构造器，即构造重载 构造器名和类名要">
<meta property="og:type" content="article">
<meta property="og:title" content="Something of Java">
<meta property="og:url" content="https://myywee.github.io/2024/02/06/Something-of-Java/index.html">
<meta property="og:site_name" content="Myywee">
<meta property="og:description" content="Something of JavaJava的构造器基本语法  [修饰符] 方法名（形参列表） {方法体} 构造器没有返回值 方法名和类名字必须一样 参数列表和成员方法一样的规则 构造器的调用由系统完成  基本介绍 构造器（constructor）又叫构造方法，是类的一种特殊方法，它的主要作用是完成对新对象的初始化。 注意事项和使用细节  一个类可以定义多个不同的构造器，即构造重载 构造器名和类名要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myywee.github.io/images/Something-of-Java/1708414372901.png">
<meta property="og:image" content="https://myywee.github.io/images/Something-of-Java/1708607140211.png">
<meta property="article:published_time" content="2024-02-06T09:36:42.000Z">
<meta property="article:modified_time" content="2024-02-29T11:01:59.578Z">
<meta property="article:author" content="Myywee">
<meta property="article:tag" content="Notes">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://myywee.github.io/images/Something-of-Java/1708414372901.png">
  
  
  
  <title>Something of Java - Myywee</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"myywee.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Myywee</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/content.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Something of Java"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Myywee
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-06 17:36" pubdate>
          2024年2月6日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          54 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Something of Java</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Something-of-Java"><a href="#Something-of-Java" class="headerlink" title="Something of Java"></a>Something of Java</h1><h2 id="Java的构造器"><a href="#Java的构造器" class="headerlink" title="Java的构造器"></a>Java的构造器</h2><p><strong>基本语法</strong></p>
<ul>
<li>[修饰符] 方法名（形参列表） {<br>方法体<br>}</li>
<li>构造器没有返回值</li>
<li>方法名和类名字必须一样</li>
<li>参数列表和成员方法一样的规则</li>
<li>构造器的调用由系统完成</li>
</ul>
<p><strong>基本介绍</strong></p>
<p><strong>构造器</strong>（constructor）又叫构造方法，是类的一种特殊方法，它的主要作用是<strong>完成对新对象的初始化</strong>。</p>
<p><strong>注意事项和使用细节</strong></p>
<ol>
<li>一个类可以定义多个不同的构造器，即构造重载</li>
<li>构造器名和类名要相同</li>
<li>构造器没有返回值</li>
<li>构造器是完成对象的初始化，并不是创建对象</li>
<li>在创建对象时，系统自动的调用该类的构造方法</li>
<li>如果没有定义构造方法，系统会自动给类生成一个默认无参构造方法（也叫默认构造方法）。</li>
<li>一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下，即自己构造一个无参构造器。</li>
</ol>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-keyword">public</span> String name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>      <span class="hljs-built_in">this</span>.name = name;<br>      <span class="hljs-built_in">this</span>.age  = age;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(name + <span class="hljs-string">&#x27;\t&#x27;</span> + age + <span class="hljs-string">&#x27;\t&#x27;</span>);  <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>java虚拟机给每个对象分配this，代表当前对象。</li>
</ul>
<p><strong>this的本质</strong></p>
<ul>
<li>哪个对象调用构造器，this就代表哪个对象</li>
</ul>
<p><img src="/../../../images/Something-of-Java/1708414372901.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>hashCode 方法会针对不同对象返回不同的整数，这一般是通过该对象的内部地址转换成一个整数来实现的</li>
</ul>
<p><strong>注意事项和使用细节</strong></p>
<ul>
<li>this关键字可以用来访问本类的属性、方法、构造器</li>
<li>this用于区分当前类的属性和局部变量</li>
<li>访问成员方法的语法：this.方法名（参数列表）</li>
<li>访问构造器语法：this（参数列表）<strong>注意只能在构造器中使用且必须放置在第一条语句</strong></li>
<li>this不能在类定义的外部使用，只能在类定义的方法中使用</li>
</ul>
<h2 id="Java访问修饰符"><a href="#Java访问修饰符" class="headerlink" title="Java访问修饰符"></a>Java访问修饰符</h2><ul>
<li><strong>public</strong> ：公开级别，对外公开</li>
<li><strong>protected</strong> : 受保护级别，对子类和同一个包中的类公开</li>
<li><strong>默认</strong> ：默认级别，向同一个包的类公开</li>
<li><strong>private</strong> : 私有级别，只有类本身可以访问，不对外公开</li>
</ul>
<table>
<thead>
<tr>
<th>访问级别</th>
<th>访问控制修饰符</th>
<th>同类</th>
<th>同包</th>
<th>子类</th>
<th align="center">不同包</th>
</tr>
</thead>
<tbody><tr>
<td>公开</td>
<td>public</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td align="center">+</td>
</tr>
<tr>
<td>受保护</td>
<td>protected</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td align="center">-</td>
</tr>
<tr>
<td>默认</td>
<td>没有修饰符</td>
<td>+</td>
<td>+</td>
<td>-</td>
<td align="center">-</td>
</tr>
<tr>
<td>私有</td>
<td>private</td>
<td>+</td>
<td>-</td>
<td>-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p> <strong>使用的注意事项</strong></p>
<ol>
<li>修饰符可以用来修饰类中的属性，成员方法以及类</li>
<li>只有默认的public和默认才能修饰类，并且遵循上述访问权限的特点</li>
<li>成员方法的访问规则和属性完全一样</li>
</ol>
<h2 id="Java-的封装（encapsulation）"><a href="#Java-的封装（encapsulation）" class="headerlink" title="Java 的封装（encapsulation）"></a>Java 的封装（encapsulation）</h2><p><strong>基本介绍</strong></p>
<ul>
<li><strong>封装</strong>就是把抽象的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（方法）才能对数据进行操作。</li>
<li><strong>封装的理解和好处</strong>：（1）隐藏实现细节 （2）可以对数据进行验证，保证安全合理</li>
</ul>
<p><strong>封装步骤</strong></p>
<ol>
<li>将属性私有化（不能直接修改属性）</li>
<li>提供一个公共的set方法，用于对属性进行判断和赋值</li>
<li>提供一个公共的get方法，用于获取属性的值</li>
</ol>
<h2 id="Java-的继承-（extend）"><a href="#Java-的继承-（extend）" class="headerlink" title="Java 的继承 （extend）"></a>Java 的继承 （extend）</h2><p><strong>基本介绍</strong></p>
<ul>
<li><strong>继承</strong> 解决多个类出现重复内容的情况，即解决代码复用</li>
<li>当多个类存在相同的属性（变量) 和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类都不需要定义这些属性和方法，只需要通过extends来声明继承父类即可</li>
<li>使用继承后，代码的复用性、扩展性和维护性得到提高</li>
</ul>
<p><strong>基本语法</strong></p>
<p><strong>class 子类 extends 父类 {</strong></p>
<p><strong>}</strong></p>
<ol>
<li>子类就会自动拥有父类定义的属性和方法</li>
<li>父类又叫 超类，基类</li>
<li>子类又叫派生类</li>
</ol>
<p><strong>使用细节</strong></p>
<ol>
<li>子类继承了所有的属性和方法，但是私有属性不能在子类直接访问，要通过公共的方法去访问</li>
<li>子类必须调用父类的构造器，完成父类的初始化</li>
<li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过</li>
<li>如果希望指定调用父类的某个构造器，则是显示的调用一下：super（参数列表）</li>
<li>super在使用时，需要放在构造器的第一行</li>
<li>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li>
<li>Java所有类都是Object的子类</li>
<li>父类构造器的调用不限于直接父类，将一直往上追溯到Object类（顶级父类）</li>
<li>子类最多只能继承一个父类（指直接继承），即Java中是单继承机制</li>
<li>不能滥用继承，子类和父类之间必须满足一定的逻辑关系</li>
</ol>
<p><strong>继承的本质</strong></p>
<p><img src="/../../../images/Something-of-Java/1708607140211.png" srcset="/img/loading.gif" lazyload></p>
<p>对于不同的name，根据查找关系返回信息：（1）首先看子类是否存在该属性 （2）若子类存在属性并且可以访问，则返回信息 ;若子类存在属  性不可访问，则访问失败（3）若子类无此属性，向上查找</p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p><strong>基本介绍</strong></p>
<ul>
<li>super代表父类的引用，用于访问父类的属性、方法、构造器</li>
<li>基本语法：（1）访问父类的属性，但不能访问父类的private [super.属性名]；（2）访问父类的方法，不能访问父类的private方法[super.方法名(参数列表)]；（3）访问父类的构造器 [super(参数列表)]，只能放在构造器的第一行</li>
</ul>
<p><strong>使用细节</strong></p>
<ul>
<li>当子类和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。若无重名，使用super、this、直接访问效果一样</li>
<li>super的访问不限于直接父类，如果父类的超类和本类中有同名的成员，也可以使用super去访问父类的超类的成员；如果多个超类中都有同名的成员，使用super访问遵循就近原则</li>
</ul>
<p><strong>super和this的比较</strong></p>
<p><strong>区别点</strong>：（1）访问属性：super访问父类中的属性；this访问本类中的属性，如果本类没有此属性则从父类中继续查找。（2）调用方法：super直接访问父类中的方法；this访问本类的方法，如果本类没有此方法则从父类中继续查找。（3）调用构造器：super调用父类构造器，必须放在子类构造器的首行；this调用本类构造器，必须放在构造器的首行。（4）特殊：supe表示子类中访问父类对象；this表示当前对象</p>
<h2 id="方法重写-覆盖（override）"><a href="#方法重写-覆盖（override）" class="headerlink" title="方法重写&#x2F;覆盖（override）"></a>方法重写&#x2F;覆盖（override）</h2><p><strong>基本介绍</strong></p>
<p>方法覆盖&#x2F;重写就是子类有一个方法和父类的某个方法的名称、返回类型、参数一致，那么我们就说子类的这个方法覆盖了父类的那个方法</p>
<p><strong>注意事项和使用细节</strong></p>
<ul>
<li>子类的方法的参数，方法名称要和父类方法的参数，方法名称完全一样</li>
<li>子类方法的返回类型和父类方法返回类型一样，或者时父类返回类型的子类，例如：父类方法返回类型是Object，子类方法返回类型是String</li>
<li>子类方法不能缩小父类方法的访问权限</li>
</ul>
<h2 id="Java-的多态（polymophic）"><a href="#Java-的多态（polymophic）" class="headerlink" title="Java 的多态（polymophic）"></a>Java 的多态（polymophic）</h2><p><strong>基本介绍</strong></p>
<ul>
<li>方法或者对象具有多种形态，是建立在封装和继承基础之上的</li>
</ul>
<p><strong>具体实现</strong></p>
<ol>
<li>方法的多态：方法的多态：重写和重载体现方法的多态</li>
<li>对象的多态： （1）一个对象的编译类型和运行类型可以不一致（2）编译类型在定义对象时就确定了，不能改变（3）运行类型是可以变化的 （4）编译类型看定义时“&#x3D;”的左边，运行类型看“&#x3D;”的右边</li>
<li>Animal animal &#x3D; new Dog() （animal的编译类型是Animal，运行类型是Dog） ;animal &#x3D; new Cat()（animal的运行类型变成了Cat，编译类型仍然是Animal）</li>
<li>可以简单的认为编译类型是提供给编译器的类型，而运行类型是Java运行时的实际类型</li>
</ol>
<p><strong>注意事项和细节讨论</strong></p>
<ul>
<li>多态的前提：两个对象（类）存在继承关系</li>
</ul>
<p><strong>多态的向上转型</strong></p>
<ol>
<li>本质：父类的引用指向子类的对象</li>
<li>语法：父类类型 引用名 &#x3D; new 子类类型();</li>
<li>特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员（需遵守访问权限），不能调用子类中的特有成员（调用哪些成员是由编译类型决定的）；最终运行效果看子类的具体实现</li>
</ol>
<p><strong>多态的向下转型</strong></p>
<ol>
<li>语法：子类类型 引用名 &#x3D; （子类类型）父类引用</li>
<li>只能强转父类的引用，不能强转父类的对象</li>
<li>要求父类的引用必须指向的是当前目标类型的对象</li>
<li>当向下转型后，可以调用子类类型中所有的成员</li>
</ol>
<ul>
<li>属性没有重写一说，属性看编译类型</li>
<li>instanceOf 比较操作符，用于判断对象的运行类型是否为某类型或者其子类类型</li>
</ul>
<p><strong>Java的动态绑定机制</strong></p>
<ol>
<li>当调用对象方法的时候，该方法会和该对象的内存地址（运行类型）绑定</li>
<li>当调用对象属性时，没有动态绑定机制，哪里声明哪里使用</li>
</ol>
<p><strong>多态的应用</strong></p>
<ol>
<li>多态数组：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</li>
<li>多态参数：方法定义的形参类型为父类类型，实参类型允许为子类类型</li>
</ol>
<h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h3><p><strong>equals和“&#x3D;&#x3D;”的对比</strong></p>
<ol>
<li>&#x3D;&#x3D;：既可以判断基本类型，又可以判断引用类型</li>
<li>&#x3D;&#x3D;：如果判断基本类型，判断的是值是否相等</li>
<li>&#x3D;&#x3D;：如果判断引用类型，判断的是地址是否相同，即判断是不是同一个对象</li>
<li>equals：是Object类中的方法，只能判断引用类型</li>
<li>equals：默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等</li>
</ol>
<h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode 方法"></a>hashCode 方法</h3><ol>
<li>提高具有哈希结构的容器的效率</li>
<li>两个引用如果指向的是同一个对象，则哈希值是相同的</li>
<li>两个引用如果指向的是不同对象，则哈希值是不同的</li>
<li>哈希值主要根据地址号，但是不能完全将哈希值等同于地址</li>
</ol>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h3><p><strong>基本介绍</strong></p>
<ul>
<li>默认返回：全类名 + @ + 哈希值的十六进制，子类默认往往重写toString方法，用于返回队形的属性信息</li>
<li>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式</li>
<li>当直接输出一个对象时，toString方法会被默认调用</li>
</ul>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize 方法"></a>finalize 方法</h3><ol>
<li>当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法，程序员就可以在finalize方法中写自己的业务逻辑代码（比如释放资源，数据库连接或者打开文件）</li>
<li>当某个对象没有任何引用时，jvm认为此对象是一个垃圾对象，使用垃圾回收机制来销毁该对象，在销毁该对象前，会调用finalize方法</li>
<li>垃圾回收机制的调用，是由系统决定，可以通过System.gc()主动触发垃圾回收机制</li>
</ol>
<h2 id="类变量和类方法"><a href="#类变量和类方法" class="headerlink" title="类变量和类方法"></a>类变量和类方法</h2><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p><strong>static</strong>：当类中的一个变量被static修饰为静态变量，可以被该类的所有对象实例共享，static类变量在类加载时生成</p>
<p><strong>定义</strong></p>
<p>类变量也叫静态变量&#x2F;静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量变量**</p>
<p><strong>定义类变量</strong></p>
<p>定义语法：</p>
<p>访问修饰符 static 数据类型 变量名;【推荐】</p>
<p>static 访问修饰符 数据类型 变量名;</p>
<p><strong>访问类变量</strong></p>
<p>类名.类变量名【推荐使用】 或 对象名.类变量名【静态变量的访问修饰符的访问权限和范围 和普通属性是一样的】</p>
<p><strong>类变量使用注意事项和细节讨论</strong></p>
<ol>
<li>何时需要类变量：当我们需要让某个类的所有对象都共享一个变量时，可以考虑使用类变量（静态变量）</li>
<li>类变量与实例变量区别：类变量是该类的所有对象共享的，而实例变量是每个对象独享的</li>
<li>加上static称为类变量或静态变量，否则称为实例变量&#x2F;普通变量&#x2F;非静态变量</li>
<li>实例变量不能通过 类名.类变量名 方式访问</li>
<li>类变量是在类加载时就初始化了，也就是说，即使没有创建对象，只要类加载了就可以使用类变量</li>
<li>类变量的生命周期是随类加载开始，随着类消亡而销毁</li>
</ol>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p><strong>类方法基本介绍</strong></p>
<p>类方法也叫静态方法</p>
<p>形式如下：</p>
<p>访问修饰符 static 数据返回类型 方法名(){ }【推荐】</p>
<p>static 访问修饰符 数据返回类型 方法名(){ }</p>
<p><strong>类方法的调用</strong></p>
<p>使用方法：类名.类方法名 或 对象名.类方法名</p>
<p><strong>类方法经典使用场景</strong></p>
<p>当方法中不涉及到任何和对象相关的成员可以将方法设计成静态方法提高开发效率，在程序员实际开发中往往会将一些通用的方法设计成静态方法，这样不需要创建对象就可以使用该方法</p>
<p><strong>类方法使用注意事项和细节讨论</strong></p>
<ol>
<li>类方法和普通方法都是随类的加载而加载，将结构信息存储在方法区：类方法中无this的参数，普通方法中隐含着this的参数</li>
<li>类方法可以通过类名调用，也可以通过对象名调用</li>
<li>普通方法和对象有关需要通过对象名调用，不能通过类名调用</li>
<li>类方法中不允许使用和对象有关的关键字，例如this和super；普通方法可以</li>
<li>类方法中只能访问静态变量或静态方法</li>
<li>普通成员方法既可以访问普通方法也可以访问静态方法</li>
</ol>
<h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h2><p><strong>深入理解main方法</strong></p>
<p>解释main方法的形式：public static void main(String[] args){ }</p>
<ol>
<li>Java虚拟机需要调用类的main() 方法，所以该方法的访问权限必须是public</li>
<li>Java虚拟机在执行main()方法时不必创建对象，所以方法必须是static</li>
<li>该方法接收String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数</li>
</ol>
<p><strong>特别提示</strong></p>
<ol>
<li>在main()方法中可以直接调用main方法所在类的静态方法或属性</li>
<li>不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后才能通过这个对象访问类中的非静态成员</li>
</ol>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p><strong>基本介绍</strong></p>
<p>代码块又称为初始化块，属于类中的成员（即是类的一部分），类似于方法，将逻辑语句封装在方法中，通过{}包围起来</p>
<p>与方法不同，，无方法名返回值参数，只有方法体，不通过对象或类显式调用，而是加载类时或者创建对象时隐式调用</p>
<p><strong>基本语法</strong></p>
<p>[修饰符] {</p>
<p>};</p>
<p>注意：</p>
<ol>
<li>修饰符只能写static或者不写</li>
<li>代码可以分为两类，使用static修饰的叫静态代码块，没有static修饰的叫普通代码块</li>
<li>逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）</li>
<li>“;”号可以写上，也可以省略</li>
</ol>
<p><strong>代码块的好处</strong></p>
<ol>
<li>相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作</li>
<li>如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性</li>
<li>代码块调用顺序优先于构造器</li>
</ol>
<p><strong>代码块使用注意事项和细节讨论</strong></p>
<ol>
<li>static代码块也叫静态代码，作用对类进行初始化，随类加载而执行并且只会执行一次；如果是普通代码块，每创建一个对象即执行一次</li>
<li>加载类的时期：（1）创建对象实例（new）（2）创建子类对象实例，父类也会被加载，父类先加载子类后加载（3）使用类的静态成员时（静态属性、静态方法）</li>
<li>普通的代码块在创建对象实例时会被隐式地调用，被创建一次就会被调用一次；如果只是使用类的静态成员时，普通代码块并不会执行</li>
<li>创建一个对象时，在一个类调用顺序：（1）调用静态代码代码块和静态属性初始化（<strong>注意</strong>：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态属性初始化，则按定义的顺序调用）（2）调用普通代码块和普通属性的初始化（<strong>注意</strong>：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）（3）调用构造器</li>
<li>构造器的最前面隐含了super()和调用普通代码块；静态相关的代码块，属性初始化，在类加载时就执行完毕</li>
<li>创建子类时静态代码块、静态属性初始化、普通代码块、普通属性初始化、构造方法的调用顺序：（1）父类的静态代码块和静态属性（优先级一样按照定义顺序执行）（2）子类的静态代码块和静态属性（优先级一样按照定义顺序执行）（3）父类的普通代码块和普通属性初始化（优先级一样按照定义顺序执行）（4）父类的构造方法（5）子类的普通代码块和普通属性初始化（优先级一样按照定义顺序执行）（6）子类的构造方法</li>
<li>静态代码块只能调用静态成员和方法</li>
</ol>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p><strong>基本介绍</strong></p>
<p>所谓类的单例设计模式，就是采取一定的方法保证在整个软件系统中对某个类只能存在一个对象实例并且该类只提供一个取得其对象实例的方法；单例模式共有两种方式：（1）饿汉式（2）懒汉式</p>
<p><strong>饿汉式</strong></p>
<p><strong>步骤</strong></p>
<ol>
<li>构造器私有化，防止用户new</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法，getInstance<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GirlFriend</span> <span class="hljs-variable">instance1</span> <span class="hljs-operator">=</span> GirlFriend.getInstance();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GirlFriend</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">GirlFriend</span> <span class="hljs-variable">gf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GirlFriend</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">//将构造器私有化、在类的内部创建、提供一个公共的static方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">GirlFriend</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GirlFriend <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> gf;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p><strong>懒汉式</strong></p>
<ol>
<li>构造器私有化</li>
<li>定义一个static属性对象</li>
<li>提供一个public的static方法可以返回一个Cat对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>	<span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Cat cat;<br>    <span class="hljs-comment">//将构造器私有化、定义一个static属性的对象、提供一个public的static方法可以放回一个Cat对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>	<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cat <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(cat == <span class="hljs-literal">null</span>) cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> cat;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>懒汉式VS饿汉式</strong></p>
<ol>
<li>二者主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建</li>
<li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</li>
<li>饿汉式存在浪费资源的问题，若对象实例未被使用则创建的对象就浪费了</li>
</ol>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><strong>基本介绍</strong></p>
<ol>
<li>final可以修饰类、属性、方法和局部变量</li>
<li>当不希望类被继承时可以用final修饰</li>
<li>当不希望父类的某个方法被子类覆盖&#x2F;重写时可以用final关键字修饰</li>
<li>当不希望类的某个属性的值被修改，可以用final修饰</li>
<li>当不希望某个局部变量被修改，可以用final修饰</li>
</ol>
<p><strong>使用事项和细节讨论</strong></p>
<ol>
<li>final修饰的属性又叫常量</li>
<li>final修饰的属性在定义是必须赋初值，并且以后不能再修改，赋值可以在（1）定义时（2）在构造器中（3）在代码块中</li>
<li>如果final修饰的属性是静态的，则初始化的位置只能是（1）定义时（2）在静态代码块中（3）不能在构造器中赋值</li>
<li>final类不能被继承但是可以被实例化 </li>
<li>如果类不是final类，但是含有final方法，则该方法虽然不能重写但是可以被继承</li>
<li>一般来说，如果一个类已经是final类就没有必要将方法修饰成final方法</li>
<li>final不能修饰构造方法</li>
<li>final和static往往搭配使用，不会导致类加载，效率更高，底层编译器做了优化处理</li>
</ol>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>基本介绍</strong></p>
<ol>
<li>当父类的一些方法不能确定时可以使用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</li>
<li>一般来说，抽象类会被继承，由其子类来实现</li>
<li>抽象类：访问修饰符 abstract 类名{}</li>
<li>抽象方法：访问修饰符 abstract 返回类型 方法名(参数列表)（无方法体）</li>
<li>抽象类的价值在于设计，让子类继承并实现抽象类</li>
</ol>
<p><strong>使用注意事项和细节讨论</strong></p>
<ol>
<li>抽象类不能被实例化</li>
<li>抽象类不一定要包含abstract方法，也就是说抽象类可以没有abstract方法</li>
<li>一旦类包含了abstract方法，则这个类必须声明为abstract</li>
<li>abstract只能修饰类和方法，不能修饰属性和其它的</li>
<li>抽象类可以有任意成员，例如非抽象方法、构造器、静态属性；抽象方法不能有主题，即不能实现</li>
<li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类</li>
<li>抽象方法不能使用private、final和static来修饰，因为这些关键字是和重写相违背的</li>
</ol>
<p><strong>抽象类——模板设计模式</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>基本介绍</strong></p>
<p>接口就是给出一些没有实现的方法封装到一起，在某个类要使用的时候根据具体情况将这些方法写出来</p>
<p><strong>语法</strong><br>interface 接口名{</p>
<p>   &#x2F;&#x2F;属性</p>
<p>   &#x2F;&#x2F;方法</p>
<p>}	</p>
<p>class 类名 implements 接口{</p>
<p>   &#x2F;&#x2F;自己的属性&#x2F;自己的方法</p>
<p>   &#x2F;&#x2F;必须实现接口的抽象方法</p>
<p>}</p>
<p>Jdk7.0前接口里的所有方法都没有方法体，即都是抽象方法</p>
<p>Jdk8.0后接口可以有静态方法、默认方法，也就是说接口中可以有方法的具体实现</p>
<p><strong>注意事项和使用细节</strong></p>
<ol>
<li>接口不可以被实例化</li>
<li>接口中的所有方法都是public方法，接口中的抽象方法可以不用abstract修饰</li>
<li>一个普通类实现接口就必须将该接口的所有方法都实现</li>
<li>抽象类实现接口时可以不实现接口的抽象方法</li>
<li>一个类同时可以实现多个接口、</li>
<li>接口中的属性只能是final的而且是public、static、final修饰符</li>
<li>接口中属性的访问形式：接口名.属性名</li>
<li>一个接口不能继承其它的类但是可以继承多个别的接口 interface A extends B,C{} </li>
<li>接口的修饰符只能是public和默认，与类的修饰符相同</li>
</ol>
<p><strong>实现接口VS继承类</strong></p>
<ol>
<li>继承的价值在于：解决代码的复用性和可维护性；接口的价值在于：设计好各种规范方法，让其它类区实现这些方法</li>
<li>接口比继承更加灵活，继承满足is-a关系，接口只需满足like-a的关系</li>
<li>接口在一定程度上实现代码解耦：接口规范和动态绑定机制</li>
</ol>
<p><strong>接口的多态特性</strong></p>
<ol>
<li>多态参数：接口作为参数时，实际参数可以是完成该接口方法的类</li>
<li>多态数组：接口的多态数组用法与之前类似</li>
<li>接口存在多态传递现象</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Notes/" class="print-no-link">#Notes</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Something of Java</div>
      <div>https://myywee.github.io/2024/02/06/Something-of-Java/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Myywee</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      
<i class="iconfont icon-love"></i>

    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
